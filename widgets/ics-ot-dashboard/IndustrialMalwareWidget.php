<?php
/**
 * Industrial Malware Family Tracking Widget
 *
 * Bar chart showing industrial malware families observed in recent events.
 * Tracks ICS-specific malware like TRITON, INDUSTROYER, PIPEDREAM, etc.
 *
 * @package    MISP
 * @subpackage Dashboard.Custom
 * @author     tKQB Enterprises
 * @license    AGPL-3.0
 * @version    1.0
 * @since      MISP 2.4.x
 */

class IndustrialMalwareWidget
{
    public $title = 'Industrial Malware Families';
    public $render = 'BarChart';
    public $width = 6;
    public $height = 5;
    public $params = array(
        'timeframe' => 'Time window for analysis (1d, 7d, 30d, 90d, 1y)',
        'limit' => 'Maximum malware families to display (default: 10)'
    );
    public $description = 'Tracking of ICS-specific malware families (TRITON, INDUSTROYER, etc.)';
    public $cacheLifetime = 300;
    public $autoRefreshDelay = 60;
    public $placeholder =
'{
    "timeframe": "30d",
    "limit": "10"
}';

    // Known ICS malware families
    private $icsMalware = array(
        'triton' => array('name' => 'TRITON/TRISIS', 'color' => '#c0392b', 'aliases' => array('triton', 'trisis', 'hatman')),
        'industroyer' => array('name' => 'INDUSTROYER', 'color' => '#e74c3c', 'aliases' => array('industroyer', 'crashoverride', 'industroyer2')),
        'pipedream' => array('name' => 'PIPEDREAM', 'color' => '#8e44ad', 'aliases' => array('pipedream', 'incontroller')),
        'stuxnet' => array('name' => 'Stuxnet', 'color' => '#2980b9', 'aliases' => array('stuxnet')),
        'havex' => array('name' => 'Havex', 'color' => '#27ae60', 'aliases' => array('havex', 'dragonfly')),
        'blackenergy' => array('name' => 'BlackEnergy', 'color' => '#34495e', 'aliases' => array('blackenergy', 'be2', 'be3')),
        'irongate' => array('name' => 'IRONGATE', 'color' => '#f39c12', 'aliases' => array('irongate')),
        'fuxnet' => array('name' => 'Fuxnet', 'color' => '#16a085', 'aliases' => array('fuxnet')),
        'ekans' => array('name' => 'EKANS/SNAKE', 'color' => '#d35400', 'aliases' => array('ekans', 'snake')),
        'cosmicenergy' => array('name' => 'COSMICENERGY', 'color' => '#9b59b6', 'aliases' => array('cosmicenergy')),
        'sandworm' => array('name' => 'Sandworm', 'color' => '#95a5a6', 'aliases' => array('sandworm', 'voodoo bear'))
    );

    public function handler($user, $options = array())
    {
        $timeframe = !empty($options['timeframe']) ? $options['timeframe'] : '30d';
        $limit = !empty($options['limit']) ? intval($options['limit']) : 10;

        /** @var Event $Event */
        $Event = ClassRegistry::init('Event');

        $filters = array(
            'last' => $timeframe,
            'published' => 1,
            'tags' => array('malware', 'ics:%'),
            'limit' => 5000,
            'includeEventTags' => 1
        );

        try {
            $eventData = $Event->restSearch($user, 'json', $filters);
            if ($eventData === false) {
                return array('data' => array());
            }

            $eventJson = $eventData->intoString();
            $response = JsonTool::decode($eventJson);

            if (empty($response['response'])) {
                return array('data' => array());
            }

            $events = $response['response'];
        } catch (Exception $e) {
            return array('data' => array());
        }

        $malwareCounts = array();
        $malwareColors = array();

        foreach ($events as $eventWrapper) {
            $event = isset($eventWrapper['Event']) ? $eventWrapper['Event'] : $eventWrapper;

            // Build searchable text
            $searchText = '';
            if (!empty($event['info'])) {
                $searchText .= ' ' . strtolower($event['info']);
            }

            if (!empty($event['EventTag'])) {
                foreach ($event['EventTag'] as $tagData) {
                    if (isset($tagData['Tag']['name'])) {
                        $searchText .= ' ' . strtolower($tagData['Tag']['name']);
                    }
                }
            }

            if (!empty($event['Attribute'])) {
                foreach ($event['Attribute'] as $attr) {
                    if (!empty($attr['comment'])) {
                        $searchText .= ' ' . strtolower($attr['comment']);
                    }
                }
            }

            // Check for malware family matches
            foreach ($this->icsMalware as $key => $info) {
                foreach ($info['aliases'] as $alias) {
                    if (strpos($searchText, $alias) !== false) {
                        $displayName = $info['name'];

                        if (!isset($malwareCounts[$displayName])) {
                            $malwareCounts[$displayName] = 0;
                            $malwareColors[$displayName] = $info['color'];
                        }
                        $malwareCounts[$displayName]++;
                        break; // Count once per event
                    }
                }
            }
        }

        arsort($malwareCounts);
        $malwareCounts = array_slice($malwareCounts, 0, $limit, true);

        return array(
            'data' => $malwareCounts,
            'colours' => $malwareColors
        );
    }

    public function checkPermissions($user)
    {
        if (!empty($user['Role']['perm_auth'])) {
            return true;
        }
        return false;
    }
}
