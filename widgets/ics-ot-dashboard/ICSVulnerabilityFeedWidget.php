<?php
/**
 * ICS Vulnerability Feed Widget
 *
 * SimpleList showing recent ICS-specific vulnerabilities from various feeds
 * including ICS-CERT, vendor advisories, and CVE databases.
 *
 * @package    MISP
 * @subpackage Dashboard.Custom
 * @author     tKQB Enterprises
 * @license    AGPL-3.0
 * @version    1.0
 * @since      MISP 2.4.x
 */

class ICSVulnerabilityFeedWidget
{
    public $title = 'ICS Vulnerability Feed';
    public $render = 'SimpleList';
    public $width = 6;
    public $height = 5;
    public $params = array(
        'timeframe' => 'Time window for analysis (1d, 7d, 30d)',
        'limit' => 'Maximum vulnerabilities to show (default: 10)',
        'severity_filter' => 'Filter by severity: critical, high, medium, low (optional)'
    );
    public $description = 'Recent ICS-specific vulnerabilities and advisories';
    public $cacheLifetime = 300; // 5 minutes
    public $autoRefreshDelay = 60; // 1 minute
    public $placeholder =
'{
    "timeframe": "7d",
    "limit": "10",
    "severity_filter": ""
}';

    public function handler($user, $options = array())
    {
        // Parse parameters
        $timeframe = !empty($options['timeframe']) ? $options['timeframe'] : '7d';
        $limit = !empty($options['limit']) ? intval($options['limit']) : 10;
        $severityFilter = !empty($options['severity_filter']) ? strtolower($options['severity_filter']) : '';

        /** @var Event $Event */
        $Event = ClassRegistry::init('Event');

        // Build filters
        $filters = array(
            'last' => $timeframe,
            'published' => 1,
            'tags' => array('ics:', 'vulnerability'),
            'limit' => 1000,
            'includeEventTags' => 1,
            'metadata' => false
        );

        // Fetch events
        try {
            $eventData = $Event->restSearch($user, 'json', $filters);
            if ($eventData === false) {
                return array();
            }

            $eventJson = $eventData->intoString();
            $response = JsonTool::decode($eventJson);

            if (empty($response['response'])) {
                return array();
            }

            $events = $response['response'];
        } catch (Exception $e) {
            return array();
        }

        $baseUrl = Configure::read('MISP.baseurl');
        $data = array();
        $vulnCount = 0;

        foreach ($events as $eventWrapper) {
            if ($vulnCount >= $limit) {
                break;
            }

            $event = isset($eventWrapper['Event']) ? $eventWrapper['Event'] : $eventWrapper;

            // Extract CVE or vulnerability info
            $vulnInfo = $this->extractVulnerabilityInfo($event);

            if (empty($vulnInfo)) {
                continue;
            }

            // Apply severity filter
            if (!empty($severityFilter) && !empty($vulnInfo['severity'])) {
                if (strtolower($vulnInfo['severity']) !== $severityFilter) {
                    continue;
                }
            }

            // Truncate long event titles
            $eventInfo = !empty($event['info']) ? $event['info'] : 'Event ' . $event['id'];
            if (strlen($eventInfo) > 60) {
                $eventInfo = substr($eventInfo, 0, 57) . '...';
            }

            $data[] = array(
                'title' => $eventInfo,
                'value' => $vulnInfo['cve'] . ' - ' . $vulnInfo['severity'],
                'html' => sprintf(
                    ' (<a href="%s">%s</a>)',
                    $baseUrl . '/events/view/' . $event['id'],
                    __('View')
                )
            );

            $vulnCount++;
        }

        // If no matches, show message
        if (empty($data)) {
            $data[] = array(
                'title' => __('No ICS vulnerabilities'),
                'value' => __('in timeframe'),
                'html' => ''
            );
        }

        return $data;
    }

    /**
     * Extract vulnerability information from event
     */
    private function extractVulnerabilityInfo($event)
    {
        $vulnInfo = array(
            'cve' => 'N/A',
            'severity' => 'Unknown'
        );

        // Check attributes for CVE
        if (!empty($event['Attribute'])) {
            foreach ($event['Attribute'] as $attr) {
                // Look for CVE in value
                if (!empty($attr['value']) && preg_match('/CVE-\d{4}-\d+/i', $attr['value'], $matches)) {
                    $vulnInfo['cve'] = strtoupper($matches[0]);
                    break;
                }
            }
        }

        // Check tags for severity
        if (!empty($event['EventTag'])) {
            foreach ($event['EventTag'] as $tagData) {
                if (isset($tagData['Tag']['name'])) {
                    $tagName = strtolower($tagData['Tag']['name']);

                    if (strpos($tagName, 'critical') !== false) {
                        $vulnInfo['severity'] = 'Critical';
                    } elseif (strpos($tagName, 'high') !== false && $vulnInfo['severity'] === 'Unknown') {
                        $vulnInfo['severity'] = 'High';
                    } elseif (strpos($tagName, 'medium') !== false && $vulnInfo['severity'] === 'Unknown') {
                        $vulnInfo['severity'] = 'Medium';
                    } elseif (strpos($tagName, 'low') !== false && $vulnInfo['severity'] === 'Unknown') {
                        $vulnInfo['severity'] = 'Low';
                    }
                }
            }
        }

        // Only return if we found a CVE
        return ($vulnInfo['cve'] !== 'N/A') ? $vulnInfo : null;
    }

    /**
     * Check user permissions
     */
    public function checkPermissions($user)
    {
        if (!empty($user['Role']['perm_auth'])) {
            return true;
        }
        return false;
    }
}
